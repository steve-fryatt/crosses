REM >!Crosses
REM
REM Copyright 1993-2014, Stephen Fryatt (info@stevefryatt.org.uk)
REM
REM This file is part of Crosses:
REM
REM   http://www.stevefryatt.org.uk/software/
REM
REM Licensed under the EUPL, Version 1.1 only (the "Licence");
REM You may not use this work except in compliance with the
REM Licence.
REM
REM You may obtain a copy of the Licence at:
REM
REM   http://joinup.ec.europa.eu/software/page/eupl
REM
REM Unless required by applicable law or agreed to in
REM writing, software distributed under the Licence is
REM distributed on an "AS IS" basis, WITHOUT WARRANTIES
REM OR CONDITIONS OF ANY KIND, either express or implied.
REM
REM See the Licence for the specific language governing
REM permissions and limitations under the Licence.

LIBRARY "BASIC:Icon"
LIBRARY "BASIC:Menu"
LIBRARY "BASIC:Message"
LIBRARY "BASIC:Resources"
LIBRARY "BASIC:Template"
LIBRARY "BASIC:Url"
LIBRARY "BASIC:WimpError"
LIBRARY "BASIC:WimpSprite"
LIBRARY "BASIC:Window"

PROCwimperror_initialise("Crosses", "!crosses")
ON ERROR result% = FNwimperror_program : END

REM These values get replaced by tokenize.

build_version$ = "1.10"
build_date$ = "01 Jul 2009"

PROCinitialise

ON ERROR Quit% = FNwimperror_program

WHILE NOT Quit%
	PROCpoll
ENDWHILE

SYS "Wimp_CloseDown"
END


REM Handle calls to Wimp_Poll and process the responses.
:
DEF PROCpoll
LOCAL reason%

SYS "Wimp_Poll", &3C01, b% TO reason%

CASE reason% OF
	WHEN 2		: SYS "Wimp_OpenWindow",,b%
	WHEN 3		: SYS "Wimp_CloseWindow",,b%
	WHEN 6		: PROCmouse_click(b%!12, b%!16, b%!8)
	WHEN 8		: SYS "Wimp_ProcessKey",b%!24
	WHEN 9		: PROCmenu_selection(b%)
	WHEN 17, 18	: PROCuser_message(b%)
	WHEN 19		: IF b%!16 = &4AF80 THEN PROCurl_bounce(b%)
ENDCASE
ENDPROC


REM Process mouse clicks in windows.
REM
REM \param window%	The window under the mouse.
REM \param icon%	The icon under the mouse.
REM \param buttons%	The buttons involved in the selection.
:
DEF PROCmouse_click(window%, icon%, buttons%)
CASE window% OF
WHEN -2
	CASE buttons% OF
	WHEN 1, 4
		IF NOT Playing% THEN
			PROCnew_game
			PROCwindow_open(MainWindow%)
			PROCwindow_force_redraw(MainWindow%)
		ELSE
			PROCwindow_open(MainWindow%)
		ENDIF
	WHEN 2
		PROCmenu_create_iconbar(IconbarMenu%, !b%)
	ENDCASE

WHEN MainWindow%
	IF icon% >= 0 AND icon% <= 8 THEN PROCplay_square(icon%)

WHEN OptionsWindow%
	CASE icon% OF
	WHEN 10
		ComputerPlayer%=FNicon_selected(OptionsWindow%, 10)
	WHEN 7
		PROCicon_set_shaded(OptionsWindow%, 6, NOT FNicon_selected(OptionsWindow%, 7))
	WHEN 9
		PROCicon_set_shaded(OptionsWindow%, 8, NOT FNicon_selected(OptionsWindow%, 9))
	WHEN -1 : REM Was Reset
		ScoreX% = 0
		ScoreO% = 0
		GamesPlayed%=0
		PROCwrite_scores(0, 0, 0)
		PROCwindow_force_redraw(MainWindow%)
	WHEN -2 : REM Was New Game
		PROCnew_game
		PROCwindow_force_redraw(MainWindow%)
	WHEN 12
		PROCwrite_scores(ScoreX%, ScoreO%, GamesPlayed%)
		PROCwindow_force_redraw(MainWindow%)
	WHEN 13
		PROCmenu_create(0, 0, -1)
	ENDCASE

WHEN InfoWindow%
	IF buttons% = 4 AND icon% = 8 THEN
		PROCurl_launch(FNmessage_lookup("SupportURL"))
		PROCmenu_create(-1, 0, 0)
	ENDIF
ENDCASE
ENDPROC


REM Process selections from menus.
REM
REM \param		The menu selection block.
:
DEF PROCmenu_selection(block%)
LOCAL reopen%

SYS "Wimp_GetPointerInfo",,q%
reopen% = (q%!8 = 1)

CASE FNmenu_current_handle OF
WHEN IconbarMenu%
	CASE !block% OF
		WHEN 1	: OSCLI("%Filer_Run <Crosses$Dir>.!Help")
		WHEN 3	: Quit% = TRUE
	ENDCASE
ENDCASE

IF reopen% THEN PROCmenu_create(FNmenu_current_handle, 0, 0)
ENDPROC


REM Process incoming user messages.
REM
REM \param		The user message block.
:
DEF PROCuser_message(block%)
CASE block%!16 OF
	WHEN 0		: Quit% = TRUE
	WHEN &4E383	: PROCurl_bounce(b%)
ENDCASE
ENDPROC


REM Initialise ourselves, internally and with the Wimp.
:
DEF PROCinitialise
LOCAL i%, resources$, task_name$, task_sprite$, indirected_data%, indirected_size%, ibar_icon%

REM Set up the quit flag and global data blocks.

Quit% = FALSE

DIM b% 4000, q% 255, a% 255

REM Locate the application resources.

resources$ = FNresources_find_territory_folder("<Crosses$Dir>.Resources")

REM Load the messages file.

PROCmessage_initialise(resources$ + "Messages")

task_name$ = FNmessage_lookup("TaskName")
task_sprite$ = FNmessage_lookup("TaskSpr")
PROCwimperror_initialise(task_name$, task_sprite$)

REM Initialise with the Wimp.

q%!0 = &4E383
q%!4 = &4AF80
q%!8 = 0

SYS "Wimp_Initialise", 310, &4B534154, task_name$, q%

REM Load the application sprites.

SpriteArea% = FNwimpsprite_load_user_sprites("<Crosses$Dir>.SpriteFile")

REM Load the window templates

indirected_size% = 2048
DIM indirected_data% indirected_size%

PROCtemplate_open(resources$ + "Templates")
PROCtemplate_load("Board", b%, indirected_data%, indirected_size%, -1)
b%!64 = SpriteArea%
FOR i% = 0 TO 8
	b%!(88 + 32*i% + 24) = SpriteArea%
NEXT i%
SYS "Wimp_CreateWindow",,b% TO MainWindow%
PROCtemplate_load("ProgInfo", b%, indirected_data%, indirected_size%, -1)
SYS "Wimp_CreateWindow",,b% TO InfoWindow%
PROCtemplate_load("Options", b%, indirected_data%, indirected_size%, -1)
SYS "Wimp_CreateWindow",,b% TO OptionsWindow%
PROCtemplate_close

$FNicon_indirection(InfoWindow%, 4) = CHR$(169) + " Stephen Fryatt, 1993-" + MID$(build_date$, 8)
$FNicon_indirection(InfoWindow%, 6) = build_version$ + " (" + build_date$ + ")"

REM Initialise and load the menu templates

PROCmenu_initialise

b%!0 = InfoWindow%
b%!4 = OptionsWindow%
PROCmenu_load_templates(resources$ + "Menus", b%)
IconbarMenu% = b%!0

REM The following values are indexes for the arrays which follow.

Blank% = 0
Nought% = 1
Cross% = 2

REM The sprites used to represent the marks on the playing board.

DIM Sprite$(2)
Sprite$() = "-", "o", "x"

REM The values used to represent the marks on the playing board.

DIM Value%(2)
Value%() = 0, 1, 4

REM The board representation.

DIM Board%(8)
Board%() = 0

REM The subscripts into Board%() which make up the possible rows of three
REM squares that can be played.

DIM Subscript%(23)
Subscript%() = 0,1,2, 3,4,5, 6,7,8, 0,3,6, 1,4,7, 2,5,8, 0,4,8, 2,4,6

REM The row type weightings used when calculating move scores.

DIM Weighting%(12)
Weighting%() = 0,7,31,128,-15,0,0,0,-63,0,0,0,0

REM Global variables used by the game code.

Playing% = FALSE
CurrentPlayer% = FALSE
ComputerPlayer% = FALSE
Moves% = 0
ScoreX% = 0
ScoreO% = 0
GamesPlayed%=0

ibar_icon% = FNicon_create_standard_bar(-1, task_sprite$)
ENDPROC


REM Draw the contents of a grid square.
REM
REM \param square%		The square (0 to 8) to draw.
REM \param shape%		The shape index to place in teh square.
:
DEF PROCdraw_square(square%, shape%)
IF square% < 0 OR square% > 8 OR shape% < 0 OR shape% > 2 THEN ENDPROC

Board%(square%) = Value%(shape%)

PROCicon_set_indirected_text(MainWindow%, square%, Sprite$(shape%))
PROCicon_redraw(MainWindow%, square%)
ENDPROC


REM Write a message to the message field below the playing grid.
REM
REM \param colour%		The Wimp colour to use for the text.
REM \param text$		The text of the message to write.
:
DEF PROCwrite_message(colour%, text$)
PROCicon_set_indirected_text(MainWindow%, 9, text$)
PROCicon_set_colours(MainWindow%, 9, colour%, 1)
ENDPROC


REM Write the scores and the number of games to the scores field in the
REM main window.
REM
REM \param xscore%		The score for player X.
REM \param oscore%		The score for player O.
REM \param games%		The number of games played.
:
DEF PROCwrite_scores(xscore%, oscore%, games%)
LOCAL scores$

PROCicon_set_indirected_text(MainWindow%, 10, STR$(xscore%))
PROCicon_set_indirected_text(MainWindow%, 11, STR$(oscore%))

scores$ = FNmessage_lookup("Scores")
IF FNicon_selected(OptionsWindow%, 12) THEN scores$ += FNmessage_param_lookup("Of", STR$(games%), "", "", "")
PROCicon_set_indirected_text(MainWindow%, 12, scores$)

PROCicon_redraw(MainWindow%, 10)
PROCicon_redraw(MainWindow%, 11)
PROCicon_redraw(MainWindow%, 12)
ENDPROC


REM Reset the playing board, and start a new game.
:
DEF PROCnew_game
LOCAL i%

Moves%=0
Playing% = TRUE
CurrentPlayer% = TRUE

FOR i% = 0 TO 8
	PROCdraw_square(i%, Blank%)
NEXT i%

PROCwrite_message(11, FNmessage_param_lookup("Move", FNget_x_name, "", "", ""))
ENDPROC


REM Play a square on the board, assigning it to the current player.
REM
REM \param square%		The square to play (0 to 8).
:
DEF PROCplay_square(square%)
LOCAL xwin%, owin%, computer%

IF Playing% AND Board%(square%) = Value%(Blank%) THEN
	REM Play the current mouse click.

	IF CurrentPlayer% THEN
		PROCdraw_square(square%, Cross%)
		PROCwrite_message(10, FNmessage_param_lookup("Move", FNget_o_name, "", "", ""))
		Moves% += 1
	ELSE
		PROCdraw_square(square%, Nought%)
		PROCwrite_message(11, FNmessage_param_lookup("Move", FNget_x_name, "", "", ""))
	ENDIF

	REM Change players.

	CurrentPlayer% = NOT CurrentPlayer%

	REM Calculate the board, and find the computer's move for O.

	computer% = FNcalculate(xwin%, owin%)

	REM If the computer player is active, and the game isn't over,
	REM play the identified move.

	IF Moves% < 5 AND (NOT xwin%) AND ComputerPlayer% THEN
		PROCdraw_square(computer%, Nought%)
		PROCwrite_message(11, FNmessage_param_lookup("Move", FNget_x_name, "", "", ""))

		CurrentPlayer% = NOT CurrentPlayer%
	ENDIF

	REM If there has been a win, process it.

	IF xwin% OR owin% OR Moves% >= 5 THEN
		Playing% = FALSE

		IF GamesPlayed% < 99 THEN GamesPlayed% += 1
		PROCwrite_scores(ScoreX%, ScoreO%, GamesPlayed%)

		CASE TRUE OF
		WHEN xwin%
			PROCwrite_message(11, FNmessage_param_lookup("Win", FNget_x_name, "", "", ""))
			ScoreX% += 1

		WHEN owin%
			PROCwrite_message(10, FNmessage_param_lookup("Win", FNget_o_name, "", "", ""))
			ScoreO% += 1

		OTHERWISE
			PROCwrite_message(7, FNmessage_lookup("Draw"))
			IF FNicon_selected(OptionsWindow%, 11) THEN
				ScoreX% += 1
				ScoreO% += 1
			ENDIF

		ENDCASE
	ENDIF
ENDIF
ENDPROC


REM Run a calculation on the playing board, looking for winning lines
REM and identifying a move for the computer player.
REM
REM \param xwin%		TRUE if X has won; FALSE if not.
REM \param owin%		TRUE if O has won; FALSE if not.
REM \return			The best next move for O, or -1 for none.
:
DEF FNcalculate(RETURN xwin%, RETURN owin%)
LOCAL count%(), best%, maximum%, position%, i%, score%, type%, saved%

DIM count%(12)
best% = -1

maximum% = -1000
xwin% = FALSE
owin% = FALSE

FOR position% = 0 TO 8
	saved% = Board%(position%)

	REM If the computer player is active, place an O in the position
	REM before totalling up the scores.

	IF (Board%(position%) = Value%(Blank%)) AND ComputerPlayer% THEN Board%(position%) = Value%(Nought%)

	REM Count each of the rows on the grid.

	count%() = 0

	FOR i% = 0 TO 21 STEP 3
		type% = Board%(Subscript%(i%)) + Board%(Subscript%(i% + 1)) + Board%(Subscript%(i% + 2))
		count%(type%) = count%(type%) + 1
	NEXT i%

	REM Remove any change that we've just made.

	Board%(position%) = saved%

	REM If there are any complete rows, flag a win. In the event that
	REM there's both a row of Xs and a row of Os, the Xs trump as the
	REM winning O will have been put there by the computer player.

	IF count%(12) > 0 THEN
		xwin%=TRUE
	ELSE
		IF count%(3) > 0 THEN owin%=TRUE
	ENDIF

	REM If the computer player is active, score the grid with the trial
	REM O in place and track the best option we can find.

	IF (Board%(position%) = Value%(Blank%)) AND ComputerPlayer% THEN
		score% = 0
		FOR i% = 1 TO 8
			score% += count%(i%) * Weighting%(i%)
		NEXT i%

		IF score% > maximum% THEN
			maximum% = score%
			best% = position%
		ENDIF
	ENDIF
NEXT position%
=best%





REM Return a name to use for X's player.
REM
REM \return			The name to use for X.
:
DEF FNget_x_name
IF FNicon_selected(OptionsWindow%, 7) THEN =$FNicon_indirection(OptionsWindow%, 6) ELSE ="X"


REM Return a name to use for O's player.
REM
REM \return			The name to use for O.
:
DEF FNget_o_name
IF FNicon_selected(OptionsWindow%, 9) THEN =$FNicon_indirection(OptionsWindow%, 8) ELSE ="O"

